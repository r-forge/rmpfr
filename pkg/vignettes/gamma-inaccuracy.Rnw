\documentclass[article,nojss]{jss}%-- the LONGER version
%% NOTA BENE: More definitions --> further down
%%%%%%%%%%%%
%
\author{Martin M\"achler \\ ETH Zurich%
\\ April, 2022 {\tiny (\LaTeX'ed \today)}%---- for now
}
\title{Accurately Computing the Gamma Function $\Gamma(x)$}
%% for pretty printing and a nice hypersummary also set:
\Plainauthor{Martin M\"achler} %% comma-separated
\Plaintitle{Accurately Computing the Gamma Function}
%\VignetteIndexEntry{Accurately Computing Gamma}
%\VignetteDepends{Rmpfr}
%\VignetteDepends{gmp}
%\VignetteDepends{sfsmisc}
\SweaveOpts{engine=R,strip.white=true, width=8.5, height=6}
\SweaveOpts{pdf=FALSE, eps=FALSE, grdevice = pdfaCrop}
%      defined in R "<<preliminaries>>":     ^^^^^^^^

%% an abstract and keywords
\Abstract{
  Interestingly enough it lasted more than 25 years before I (re-)detected
  that \R's not perfectly accurate gamma function \code{gamma(x)}
  $ = \Gamma(x)$ can quite easily be remedied --- amazingly by
  \emph{simplifying} the underlying C source code.
}
\Keywords{Accuracy, Cancellation Error, Gamma, MPFR, Rmpfr}
%% at least one keyword must be supplied

%% publication information
%% NOTE: Typically, this can be left commented and will be filled out by the technical editor
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

%% The address of (at least) one author should be given
%% in the following format:
\Address{
	Martin M\"achler\\
	Seminar f\"ur Statistik, HG G~16\\
	ETH Zurich\\
	8092 Zurich, Switzerland\\
	E-mail: \email{maechler@stat.math.ethz.ch}\\
	URL: \url{https://stat.ethz.ch/~maechler}
}
%% It is also possible to add a telephone and fax number
%% before the e-mail in the following format:
%% Telephone: +43/1/31336-5053
%% Fax: +43/1/31336-734

%% for those who use Sweave please include the following line (with % symbols):
%% MM: this is "substituted" by  jss.cls:
%% need no \usepackage{Sweave.sty}

\usepackage[american]{babel}%for American English
\usepackage{amsmath}%sophisticated mathematical formulas with amstex (includes \text{})
\usepackage{mathtools}%fix amsmath deficiencies
\usepackage{amssymb}%sophisticated mathematical symbols with amstex (includes \mathbb{})
% \usepackage{amsthm}%theorem environments
\usepackage{bm}%for bold math symbols: \bm (= bold math)
\usepackage{enumitem}%for automatic numbering of new enumerate environments

% This is already in jss above -- but withOUT the  fontsize=\small part !!
\DefineVerbatimEnvironment{Sinput}{Verbatim}{fontsize=\small,fontshape=sl}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{fontsize=\small}
\DefineVerbatimEnvironment{Scode}{Verbatim}{fontsize=\small,fontshape=sl}
%%~-~-~-~ Make space between Sinput and Soutput smaller: ~-~-~-~~-~-~-~~-~-~-~~-~-~-~~-~-~-~
%%--- Best advice, now from :
% http://tex.stackexchange.com/questions/19359/reduce-space-between-sinput-and-soutput
\newlength{\FVtopsep}
\newlength{\FVpartopsep}
\newlength{\FVparskip}% <- added as "no. 3" by MMa (after reading fancyvrb doc)
\makeatletter
\FV@AddToHook{\FV@ListParameterHook}{\topsep=\FVtopsep\partopsep=\FVpartopsep\parskip=\FVparskip}
\makeatother
% Control the spacing around the Sinput and Soutput environments by using the lengths
%
%     \FVtopsep
%     \FVpartopsep
%     \FVparskip
%
% Both *topsep  act quite similar most of the time, more details
% can be found in the fancyvrb documentation on page 46. (MM: ==> I add FVparskip)
%To kill all extra spacing between the environments, use {0pt} in all these
%MM: When all three(!) are {0pt}, there's a large gap *after* Schunk (nothing in %between)
%--  and that (end gap) get's smaller when I set all to {1pt} -- logic??
%___TODO/FIXME: Set of experiments (with smaller Sweave file)___
\setlength{\FVtopsep}{1pt}
\setlength{\FVpartopsep}{1pt}
\setlength{\FVparskip}{\parskip}% default: \parskip
%%~-~-~-~ End {Sweave space handling} ~-~-~-~~-~-~-~~-~-~-~~-~-~-~~-~-~-~~-~-~~-~-~-~~-~-~
%%
\setkeys{Gin}{width=\textwidth}% Sweave.sty has {width=0.8\textwidth}

\newcommand*{\R}{\proglang{R}}%{\textsf{R}}
\newcommand*{\CRANpkg}[1]{\href{http://CRAN.R-project.org/package=#1}{\pkg{#1}}}
\newcommand*{\file}[1]{\code{#1}}

\newcommand*{\eps}{\varepsilon}
%- \abs{ab}  -->  | ab |   ``absolut Betrag''
\newcommand{\abs}[1]{\left| #1 \right|}
\DeclareMathOperator{\sign}{sign}
%% journal specific aliases
\newcommand*{\setcapwidth}[1]{}

%% end of declarations %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
%% include your article here, just as usual
%% Note that you should use the \pkg{}, \proglang{} and \code{} commands.
% \section[About Java]{About \proglang{Java}}
%% Note: If there is markup in \(sub)section, then it has to be escape as above.
%%
%% Note: These are explained in '?RweaveLatex' :
<<preliminaries, echo=FALSE, results=hide>>=
## Our custom graphics device:
pdfaCrop <- function(name, width, height, ...) {
    fn <- paste(name, "pdf", sep = ".")
    if(FALSE)## debug
        cat("pdfaCrop: fn = ",fn,"; call:\n\t",deparse(match.call()),"\n")
    grDevices::pdf(fn, width = width, height = height, onefile=FALSE)# ...)
    assign(".pdfaCrop.name", fn, envir = globalenv())
}
## This is used automagically :
pdfaCrop.off <- function() {
    dev.off()# for the pdf
    f <- get(".pdfaCrop.name", envir = globalenv())
    ## and now crop that file:
    pdfcrop <- "pdfcrop" # relying on PATH - fix if needed
    pdftex  <- "pdftex"  # relying on PATH - fix if needed
    system(paste(pdfcrop, "--pdftexcmd", pdftex, f, f, "1>/dev/null 2>&1"),
           intern=FALSE)
}
op.orig <-
options(width = 75,
	SweaveHooks= list(fig=function() par(mar=c(5.1, 4.1, 1.1, 2.1))),
	digits = 5,
	useFancyQuotes = "TeX",
	## for JSS, but otherwise MM does not like it:
	## prompt="R> ",
	continue="  ")# 2 (or 3) blanks: use same length as 'prompt'

if((p <- "package:fortunes") %in% search())
    try(detach(p, unload=TRUE, char=TRUE))
Sys.setenv(LANGUAGE = "en")
if(.Platform$OS.type != "windows")
  Sys.setlocale("LC_MESSAGES","C")
library("sfsmisc")# e.g., for eaxis()
library("Rmpfr")
@
%\section[Introduction]{Introduction \small~\footnote{\mythanks}}
\section{Introduction: exp(x) may be less accurate than x}

Something many people have either not been aware at all or
(as myself) forgotten:  Whereas typical arithmetic operations keep the
internal accuracy, hopefully only losing a bit or two when the operation is
implemented well, this is not the case for exponentiation when the exponent
is not close to $[-1,1]$.

If we have an $x$ with relative inaccuracy $\eps$, or to make it shorter,
directly assume we have $\tilde x := x(1+\eps)$ instead of $x$,
instead of $f(x) = \exp(x) = e^x$, we will compute
\begin{align}
  \label{eq:exp-eps}
  f(\tilde x) = \exp(x(1+\eps)) = e^{x(1+\eps)} = e^x e^{x\eps} = f(x) \cdot e^{x \eps},
\end{align}
where the relative error $\tilde\eps$ is defined (implicitly) via
\(
  f(\tilde x) = f(x) \cdot (1 + \tilde\eps),
\)
i.e., we have
\begin{align}
  \label{eq:exp-err}
  1 + \tilde \eps &= e^{x \eps} &= 1 + x\eps + (x\eps)^2/2! + \O((x\eps)^3),
                    \quad \mathrm{and hence,}\nonumber\\
     \tilde \eps &= e^{x \eps} - 1  &= x\eps + (x\eps)^2/2! + \O((x\eps)^3),
\end{align}
and hence in good cases, when $\abs{x\eps} \ll 1$, we have
$\abs{\tilde \eps} = e^{x \eps} - 1 \approx \abs{x\eps}$.

Now, given IEEE double precision arithmetic, the exponents of \code{exp()}
which do not overflow (to \code{Inf}) nor underflow to 0 are not too large,
<<exp-boundaries>>=
log(c(.Machine$double.xmin,      .Machine$double.xmax))
                                        # or, allowing denormalized values
log(c(.Machine$double.xmin/2^52, .Machine$double.xmax))
@
but still in the order of 1000, i.e., such that exponentiation loses almost
3 decimals which is not at all catastrophical, and in situations such as
graphics or analysis of noisy data often irrelevant.

Still, this is the principal reason why \code{gamma(x)} in \R, has been
losing around 3 digits in accuracy till recently.

\section{Computation of Gamma}

Our way to measure accuracy of \R's computation, is by making use of our
package \CRANpkg{Rmpfr}'s ability to do many computations with arbitrary high
precision.
The package \CRANpkg{Rmpfr} is an interface from \R to the MPFR C library.
According to Wikipedia:
\begin{quote}
  The GNU Multiple Precision Floating-Point Reliable Library (GNU MPFR) is a
  GNU portable C library for arbitrary-precision binary floating-point
  computation with correct rounding, based on GNU Multi-Precision Library.
\end{quote}

We provide a utility function that computes \code{factorial(x)} which is
defined as \code{gamma(x+1)}, both using base \R's \code{factorial()} and
the \code{factorial} (and \code{gamma()}) extensions from \pkg{Rmpfr}.

Note that these two (and many similar special math functions) are not
explicitly exported from \pkg{Rmpfr} but are used as methods of the
\code{Math} S4 group generic function.

In addition, we make use of our package \CRANpkg{sfsmisc}'s
\code{relErrV()} function which basically computes the relative error of an
approximate $\hat\theta$ of a true $\theta$,
i.e.,
$(\hat\theta - \theta)/\theta =  \hat\theta / \theta - 1$,
but gives correct (absolute) error in case $\theta=0$, or gives zero, when
both values are \code{NaN}, or \code{Inf}, and similar.

%% FIXME: Keep this "uptodate" with ~/R/Pkgs/DPQ/tests/stirlerr-tst.R  (??)
%% =====                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
%% =====  *AND* even more importantly with the R script for "old" R:
%% ./gamma-inaccuracy-4old.R
%%   ~~~~~~~~~~~~~~~~~~~~~~~
<<plot-factEr, fig=TRUE>>=
p.factEr <- function(x, precBits = 128, do2 = TRUE, type = "b", ylim1=NULL, ylim2=NULL) {
    fx <- factorial(x)
    facM <- factorial(mpfr(x, precBits))
    rE <- asNumeric(sfsmisc::relErrV(facM, fx))
    ##                       ^^^^^^^ (fx / facM - 1) but dealing with Inf, NA, etc

    fEps <-                          c(1/2, 1, 2,   10,   100)
    lEps <- eval(substitute(expression(E/2, E, 2*E, 10*E, 100*E),
                            list(E = quote(epsilon[C]))))
    plotExtr <- function() {
        mtext(R.version.string, adj=1)
        abline(v= -1 + c(10, 50), col=3, lty=2) # cutoffs in gamma() : (10, 50)
        f <- fEps; if(!par("ylog")) { abline(h=0, lty=2);  f <- c(-rev(f),f) }
        f.eps <- f * .Machine$double.eps
        abline(h = f.eps, col="orange", lty=3)
        axis(4, at=f.eps[f.eps > 0], labels=lEps, col="orange", col.axis="orange",
             las = 2, cex = 3/4)
        legend("bottomleft", "x integer", col=2, text.col=2, pch=7, bty="n")
    }
    if(do2) {
        op <- par(mfrow=2:1, mar=.1+c(2.5,3,3,2.5), mgp=c(1.6, .6, 0)); on.exit(par(op))
        plot(x, rE, type=type, ylim = ylim1, cex=1/2,
             main="relative error of   x! := factorial(x) := gamma(x+1)")
        points(rE ~ x, subset = x %% 1 == 0, col=2, pch=7)
        plotExtr()
    }

    plot(x, abs(rE), log = "y", type=type, ylim = ylim2, cex=1/2, yaxt="n",
         main="|relative error| [log scale] of   x! := factorial(x) := gamma(x+1)")
    points(abs(rE) ~ x, subset = x %% 1 == 0, col=2, pch=7)
    sfsmisc::eaxis(2)
    plotExtr()

    invisible(cbind(x, fac=fx, facM=asNumeric(facM), relErr = rE))
}

pfE1 <- p.factEr(seq(0, 49, by=1/8))
@

<<plot-factEr-full, fig=TRUE>>=
pfE2 <- p.factEr(seq(0, 170, by=1/4))
@

To compare the older and new algorithms visually, use identical ylim, so we
will use these: to compare between R versions:

<<plot-factEr-full-ylim, fig=TRUE>>=
pfE2 <- p.factEr(seq(0, 170, by=1/4), type="o",
                 ylim1 = c(-1,1)*1e-14, ylim2 = c(.5e-17, 1e-13))
@
and using positive \emph{and} negative arguments,
<<plot-factEr-neg-pos, fig=TRUE>>=
pfEpm <- p.factEr(seq(-180, 180, by=1/8), type="l", ylim2= c(1e-17, 2e-13))
@

Whereas the above plots, are for the ``current'' version of \R,
here are those for \R version 4.1.3, the last one before the change:
  % 55918 Apr  8 17:53 plot-factEr_R-4.1.3.pdf
  % 94928 Apr  8 17:53 plot-factEr-full_R-4.1.3.pdf
  % 98529 Apr  8 17:53 plot-factEr-full-ylim_R-4.1.3.pdf
  % 44183 Apr  8 17:53 plot-factEr-neg-pos_R-4.1.3.pdf
\begin{figure}[htbp]
  \includegraphics{plot-factEr_R-4_1_3.pdf}
\end{figure}
\begin{figure}[htbp]
  \includegraphics{plot-factEr-full_R-4_1_3.pdf}
\end{figure}
\begin{figure}[htbp]
  \includegraphics{plot-factEr-full-ylim_R-4_1_3.pdf}
\end{figure}
\begin{figure}[htbp]
  \includegraphics{plot-factEr-neg-pos_R-4_1_3.pdf}
\end{figure}

\subsection{Extending the domain, i.e. range(x) with finite gamma()}
In addition to always use the algorithm that starts from the interval $[0, 10]$,
we also extended the range of $x$ which gives finite
$\Gamma(x)=$\code{gamma(x)} in \R:

Find smallest and largest possible x such that gamma(x) is finite,
\emph{more}* accurately (and allowing denormalized numbers) than \R's
(internal) \code{gammalims()}, which had been hard coded to the interval
$(-170.5674972726612, 171.61447887182298)$.

The upper bound \code{'xmax'} :
<<compute-xmax>>=
str(ur <- uniroot(function(x) asNumeric(gamma(mpfr(x, 256))/.Machine$double.xmax - 1),
                  c(170,180), tol=1e-14), digits=12)
## $ root      : num 171.624376956
## $ f.root    : num -4.77490039789e-14
## $ iter      : int 15
## $ init.it   : int NA
## $ estim.prec: num 8.52651282912e-14
xmax <- ur$root
dput(xmax, , "digits") # 171.62437695630271
asNumeric(gamma(mpfr(171.62437695630271, 256))/.Machine$double.xmax - 1)
## -4.7749e-14  < 0  <==>  gamma(.) < Machine..xmax
@

The lower bound \code{'xmin'} :
<<compute-xmin>>=
str(uL <- uniroot(function(x) asNumeric(abs(gamma(mpfr(x, 256))/2^-1073.9999) - 1),
                  c(-180.1, -170.1), tol=1e-14), digits=12)
 ## $ root      : num -177.563412587
 ## $ f.root    : num 1.71550990876e-14
 ## $ iter      : int 15
 ## $ init.it   : int NA
 ## $ estim.prec: num 8.52651282912e-14
dput(uL$root, , "digits") # -177.56341258681965

asNumeric(gamma(mpfr(-177.56341258681965, 256))/2^-1073.9999 - 1)
## 1.71551e-14 > 0  <==> gamma(.) > Machine..denormalized_xmin  .. good
@
Consequently, in \R's source \file{<R>/src/nmath/gamma.c}, we now have
\begin{verbatim}
// now allowing denormalized result
# define xmin -177.56341258681965 // was -170.5674972726612
# define xmax  171.62437695630271 // was  171.61447887182298
\end{verbatim}

And indeed, we can see
<<gamma-xtreme>>=
gamma(-177.56341258681965 * (1 - c(0, 3e-16)))
gamma( 171.62437695630271 * (1 + c(0, 3e-16)))
@

% ##=======>  gamma(x) itself suffers from the fact that  exp(y) has a *large* relative error,
% ##          -------- when  |y| ~ 100 or so, more specifically, the
% ## relative error of   exp(y) =  |y| * {rel.err(y)} , since
% ##   exp(((1+ eps)*y) = exp(y) * exp(eps*y) >=  exp(y) (1 + eps*y)  and indeed,
% ## the inaccuracy of y (i.e. eps)  is blown up by a factor |y|  which is not small here!

\subsection*{Session Information}
\nopagebreak
<<sessionInfo, results=tex>>=
toLatex(sessionInfo(), locale=FALSE)
<<finalizing, echo=FALSE>>=
options(op.orig)
@
%\clearpage

% \bibliography{gamma-inacc}

\end{document}
